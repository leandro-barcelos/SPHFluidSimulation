#define NUM_THREADS 32
#define MAX_PARTICLES_PER_VOXEL 32

#pragma enable_d3d11_debug_symbols

// Buffers
Texture2D<float4> _ParticlePositionTexture;
RWStructuredBuffer<uint> _Bucket;

// Parameters
float2 _ParticleResolution;
uint3 _BucketResolution;
float3 _SimOrigin;
float3 _SimScale;

#pragma kernel CSMain

[numthreads(NUM_THREADS, NUM_THREADS, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Check if we're within texture bounds
    if (any(id.xy >= uint2(_ParticleResolution)))
        return;

    // Read particle position from texture
    float3 pos = _ParticlePositionTexture[id.xy].xyz;
    float3 normalizedPos = (pos - _SimOrigin) / _SimScale;
    uint3 index_3d = uint3(normalizedPos * _BucketResolution);
    uint index = index_3d.x + index_3d.y * _BucketResolution.x + index_3d.z * _BucketResolution.x * _BucketResolution.y;
        
    // Try to find an empty slot in the bucket
    for (uint j = 0; j < MAX_PARTICLES_PER_VOXEL; j++)
    {
        uint bucketIndex = index * MAX_PARTICLES_PER_VOXEL + j;
        uint particleIndex = id.y * uint(_ParticleResolution.x) + id.x;
        uint original;
        InterlockedCompareExchange(_Bucket[bucketIndex], uint(_ParticleResolution.x * _ParticleResolution.y), particleIndex, original);
        if (original == uint(_ParticleResolution.x * _ParticleResolution.y)) break;
    }
}
